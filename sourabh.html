<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sourabh Kakarambi | Sustainable City Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { cyan: { 450: '#00d4ff' } } } }
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        h1, h2, h3, .brand-font { font-family: 'Space Grotesk', sans-serif; }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .initiative-card { transition: all 0.3s ease; cursor: pointer; }
        .initiative-card:hover { transform: translateY(-5px); border-color: #00d4ff; }
        .modal { transition: opacity 0.3s ease-in-out; opacity: 0; pointer-events: none; }
        .modal.active { opacity: 1; pointer-events: auto; }
        pre { white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; }
        .highlight-heading { color: #00d4ff; font-weight: 700; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.05em; margin-bottom: 0.5rem; display: block; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 flex flex-col min-h-screen">

    <nav class="bg-white/90 dark:bg-gray-900/95 backdrop-blur-md sticky top-0 z-40 border-b border-gray-200 dark:border-gray-700 shadow-sm transition-colors duration-300">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <i class="fa-solid fa-city text-cyan-450 text-2xl mr-2"></i>
                    <span class="brand-font text-xl font-bold text-gray-900 dark:text-white tracking-tight">Zabrosa City</span>
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <a href="index.html" class="text-gray-600 dark:text-gray-300 hover:text-cyan-450 transition">Home</a>
                    <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition">
                        <i id="theme-icon" class="fa-solid fa-sun text-yellow-500 text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow relative fade-in">
        <div class="max-w-7xl mx-auto px-4 py-16">
            <h1 class="text-4xl font-bold text-center mb-12">Sustainable City Initiatives</h1>
            <div id="card-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"></div>
        </div>
    </main>

    <div id="caseModal" class="modal fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm" onclick="closeModal()"></div>
        <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-2xl w-full max-w-6xl max-h-[90vh] overflow-hidden flex flex-col relative z-10">
            <div class="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 id="modalTitle" class="text-2xl font-bold text-cyan-450"></h3>
                <button onclick="closeModal()" class="text-gray-500 hover:text-white"><i class="fa-solid fa-xmark text-2xl"></i></button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <span class="highlight-heading">Problem Statement</span>
                        <p id="modalProblem" class="text-gray-700 dark:text-gray-300 mb-6"></p>
                        <div id="modalDetails"></div>
                    </div>
                    <div>
                        <span class="highlight-heading">C++ Implementation</span>
                        <div class="rounded-lg overflow-hidden border border-gray-700">
                            <pre><code id="modalCode" class="language-cpp"></code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleTheme() {
            const html = document.documentElement;
            html.classList.toggle('dark');
            const icon = document.getElementById('theme-icon');
            icon.classList.toggle('fa-sun');
            icon.classList.toggle('fa-moon');
        }

        const caseData = {
            1: {
                title: "Urban Road Maintenance and Asset Management",
                problem: "Urban road networks are divided into multiple zones, each having varying levels of damage due to traffic load and environmental conditions. City authorities need to frequently update the damage values after inspections and efficiently calculate the total damage over a range of zones to prioritize maintenance work. A simple linear approach becomes inefficient as the number of zones increases.",
                approach: "This problem is solved using a Segment Tree, which is a tree-based data structure designed for efficient range queries and updates. The segment tree stores cumulative damage values for ranges of road segments, allowing quick computation of total damage in any given interval.",
                documentation: "In the system, each leaf node of the segment tree represents a single road segment, while internal nodes represent the sum of damage values of their child segments. When a road segment’s condition changes, only the relevant nodes in the tree are updated. Range queries traverse only the necessary branches, making the system suitable for real-time monitoring dashboards used by municipal authorities.",
                efficiency: "The segment tree is built in O(n) time. Both update and query operations run in O(log n) time. The space complexity is O(n), making this approach scalable for large urban road networks.",
                code: `#include <iostream>\nusing namespace std;\n\nint seg[4 * 100];\nint n;\n\nvoid build(int arr[], int node, int start, int end) {\n    if (start == end) {\n        seg[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(arr, 2*node, start, mid);\n        build(arr, 2*node+1, mid+1, end);\n        seg[node] = seg[2*node] + seg[2*node+1];\n    }\n}\n\nvoid update(int node, int start, int end, int idx, int value) {\n    if (start == end) {\n        seg[node] = value;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) update(2*node, start, mid, idx, value);\n        else update(2*node+1, mid+1, end, idx, value);\n        seg[node] = seg[2*node] + seg[2*node+1];\n    }\n}\n\nint query(int node, int start, int end, int l, int r) {\n    if (r < start || l > end) return 0;\n    if (l <= start && end <= r) return seg[node];\n    int mid = (start + end) / 2;\n    return query(2*node, start, mid, l, r) + query(2*node+1, mid+1, end, l, r);\n}\n\nint main() {\n    int roadDamage[] = {3, 5, 2, 6, 4}; n = 5;\n    build(roadDamage, 1, 0, n-1);\n    cout << "Damage in Zone 1 to 3: " << query(1, 0, n-1, 1, 3) << endl;\n    update(1, 0, n-1, 2, 1);\n    cout << "Updated damage in Zone 1 to 3: " << query(1, 0, n-1, 1, 3) << endl;\n    return 0;\n}`
            },
            2: {
                title: "Water Supply and Wastewater Management",
                problem: "Water distribution systems consist of interconnected pipelines supplying water to different regions of a city. The key challenge is to verify whether water can reach all regions from the source and to identify disconnected or faulty pipeline segments that may disrupt supply.",
                approach: "Breadth First Search (BFS) is used to traverse the pipeline network starting from the main water source. BFS explores all directly connected junctions before moving to the next level, effectively simulating water flow through the network.",
                documentation: "In this system, pipeline junctions or tanks are represented as nodes and pipelines as edges in a graph. BFS uses a queue to visit nodes level by level and marks visited nodes. Any node that remains unvisited after traversal indicates a possible blockage or disconnection in the water supply network.",
                efficiency: "The BFS algorithm runs in O(V + E) time, where V represents the number of junctions and E represents the number of pipelines. The space complexity is O(V) due to the queue and visited array.",
                code: `#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int zones = 5;\n    int pipes[5][5] = {{0,1,1,0,0},{1,0,0,1,0},{1,0,0,0,1},{0,1,0,0,0},{0,0,1,0,0}};\n    bool visited[5] = {false};\n    queue<int> q;\n    int source = 0; visited[source] = true; q.push(source);\n    cout << "Water reaches zones: ";\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        cout << u << " ";\n        for (int v = 0; v < zones; v++) {\n            if (pipes[u][v] && !visited[v]) {\n                visited[v] = true; q.push(v);\n            }\n        }\n    }\n    return 0;\n}`
            },
            3: {
                title: "Smart Energy Grid Management",
                problem: "Energy providers must connect multiple power substations using electrical cables such that the entire grid remains connected with the minimum possible installation cost. Poor planning can result in unnecessary expenditure.",
                approach: "Prim’s Algorithm is used to generate a Minimum Spanning Tree (MST). The algorithm starts from a selected substation and repeatedly adds the lowest-cost edge that connects a visited node to an unvisited one, ensuring minimum total cost without cycles.",
                documentation: "In the system model, substations are treated as graph vertices and cable installation costs as weighted edges. Prim’s Algorithm incrementally builds the power grid by selecting the most economical connections, resulting in a fully connected and cost-optimized energy network.",
                efficiency: "Using an adjacency matrix, Prim’s Algorithm has a time complexity of O(V²) and a space complexity of O(V). This is suitable for moderate-sized power grids.",
                code: `#include <iostream>\nusing namespace std;\n#define INF 999\n\nint main() {\n    int n = 4;\n    int cost[4][4] = {{INF,5,8,INF},{5,INF,10,15},{8,10,INF,20},{INF,15,20,INF}};\n    bool visited[4] = {true,false,false,false};\n    int totalCost = 0;\n    for (int edges = 0; edges < n-1; edges++) {\n        int min = INF, x = -1, y = -1;\n        for (int i = 0; i < n; i++)\n            if (visited[i])\n                for (int j = 0; j < n; j++)\n                    if (!visited[j] && cost[i][j] < min) {\n                        min = cost[i][j]; x = i; y = j;\n                    }\n        visited[y] = true; totalCost += min;\n        cout << "Power line: " << x << " -> " << y << endl;\n    }\n    cout << "Total Grid Cost: " << totalCost << endl;\n    return 0;\n}`
            },
            4: {
                title: "Solid Waste Collection and Recycling Optimization",
                problem: "Municipal waste collection vehicles must cover multiple collection points daily while minimizing fuel consumption and travel time. Inefficient routing increases operational costs and delays waste processing.",
                approach: "Dijkstra’s Algorithm is used to determine the shortest paths from a central waste collection depot to all other collection points. This ensures optimal routing for waste collection vehicles.",
                documentation: "In the system, collection points are represented as nodes and roads as weighted edges based on distance or travel cost. The algorithm maintains a distance array that continuously updates the shortest known distance to each node, enabling optimal route selection.",
                efficiency: "The time complexity of this implementation of Dijkstra’s Algorithm is O(V²), and the space complexity is O(V). This is effective for city-scale route optimization.",
                code: `#include <iostream>\nusing namespace std;\n#define INF 999\n\nint main() {\n    int n = 5;\n    int graph[5][5] = {{0,4,INF,INF,8},{4,0,2,INF,5},{INF,2,0,6,INF},{INF,INF,6,0,3},{8,5,INF,3,0}};\n    int dist[5], visited[5] = {0};\n    for(int i=0;i<n;i++) dist[i]=INF; dist[0]=0;\n    for(int i=0;i<n;i++){\n        int u=-1,min=INF;\n        for(int j=0;j<n;j++) if(!visited[j] && dist[j]<min){ min=dist[j]; u=j; }\n        visited[u]=1;\n        for(int v=0;v<n;v++) if(dist[u]+graph[u][v]<dist[v]) dist[v]=dist[u]+graph[u][v];\n    }\n    cout<<"Minimum distance from depot:\\n";\n    for(int i=0;i<n;i++) cout<<"Zone "<<i<<": "<<dist[i]<<endl;\n    return 0;\n}`
            },
            5: {
                title: "Public Transport Scheduling and Optimization",
                problem: "Public transport authorities must determine which bus or train should depart next based on the earliest scheduled time. As the number of services increases, managing schedules manually becomes inefficient.",
                approach: "A Min Heap is used to store departure times so that the earliest departure is always available at the top of the heap. This allows quick selection of the next service.",
                documentation: "In this system, each heap node represents a scheduled departure time. New schedules are inserted into the heap dynamically, and the root element always provides the next transport service to be dispatched.",
                efficiency: "Insertion into the min heap takes O(log n) time, while retrieving the earliest departure time takes O(1) time. The space complexity is O(n).",
                code: `#include <iostream>\nusing namespace std;\nint heap[50], sz = 0;\nvoid insert(int time) {\n    heap[++sz] = time; int i = sz;\n    while (i > 1 && heap[i] < heap[i/2]) { swap(heap[i], heap[i/2]); i /= 2; }\n}\nint extractMin() {\n    int min = heap[1]; heap[1] = heap[sz--]; int i = 1;\n    while (2*i <= sz) {\n        int child = 2*i;\n        if (child+1 <= sz && heap[child+1] < heap[child]) child++;\n        if (heap[i] <= heap[child]) break;\n        swap(heap[i], heap[child]); i = child;\n    }\n    return min;\n}\nint main() {\n    insert(15); insert(5); insert(20);\n    cout << "Next bus departure in minutes: " << extractMin() << endl;\n    return 0;\n}`
            },
            6: {
                title: "Emergency Response Management",
                problem: "Quickly mapping the propagation of a disaster (like a gas leak) through city zones.",
                approach: "Depth First Search (DFS) is used to explore the city's connectivity graph. Starting from the source, it recursively marks all reachable zones that are affected.",
                documentation: "The city is modeled as a graph of zones. DFS ensures every single interconnected path is checked, identifying all potential hazard zones for evacuation.",
                efficiency: "The DFS algorithm runs in O(V + E) time, making it highly responsive in disaster scenarios.",
                code: `#include <iostream>\nusing namespace std;\nint city[6][6] = {{0,1,0,0,1,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,0,1,0},{1,0,0,1,0,1},{0,0,0,0,1,0}};\nbool visited[6];\nvoid dfs(int zone) {\n    visited[zone] = true; cout << zone << " ";\n    for (int i = 0; i < 6; i++) if (city[zone][i] && !visited[i]) dfs(i);\n}\nint main() { cout << "Affected zones: "; dfs(0); return 0; }`
            },
            7: {
                title: "Smart Parking – Slot Allocation System",
                problem: "Parking systems must allocate slots fairly and efficiently so that vehicles are served in the order in which they arrive, avoiding conflicts and delays.",
                approach: "A Queue data structure is used to implement first-come-first-served parking slot allocation.",
                documentation: "In the system, arriving vehicles are added to the rear of the queue, and vehicles at the front are allocated parking slots as they become available. This ensures fairness and simplicity in parking management.",
                efficiency: "Both enqueue and dequeue operations take O(1) time, and the space complexity is O(n), where n is the number of waiting vehicles.",
                code: `#include <iostream>\nusing namespace std;\nint main() {\n    int parkingSlots[10]; int front = 0, rear = 0;\n    parkingSlots[rear++] = 101; parkingSlots[rear++] = 102; parkingSlots[rear++] = 103;\n    cout << "Car allocated slot: " << parkingSlots[front++] << endl;\n    cout << "Next available slot: " << parkingSlots[front] << endl;\n    return 0;\n}`
            },
            8: {
                title: "Environmental Monitoring and Climate Resilience",
                problem: "Environmental monitoring systems must track pollution levels across multiple locations where values are frequently updated. Authorities need fast computation of cumulative pollution levels for analysis and decision-making.",
                approach: "A Fenwick Tree (Binary Indexed Tree) is used to efficiently support frequent updates and prefix sum queries on pollution data.",
                documentation: "Each index of the Fenwick Tree represents a monitoring station. The tree stores partial sums, allowing pollution updates and cumulative queries to be processed efficiently, making it suitable for real-time monitoring dashboards.",
                efficiency: "Both update and query operations run in O(log n) time, and the space complexity is O(n), making this approach scalable for large environmental datasets.",
                code: `#include <iostream>\nusing namespace std;\nint BIT[20], n = 6;\nvoid update(int idx, int val) { while (idx <= n) { BIT[idx] += val; idx += idx & -idx; } }\nint query(int idx) { int sum = 0; while (idx > 0) { sum += BIT[idx]; idx -= idx & -idx; } return sum; }\nint main() { update(1, 35); update(2, 40); update(3, 30); update(4, 25);\n    cout << "Total pollution till zone 4: " << query(4) << endl; return 0; }`
            }
        };

        const icons = ["road", "water", "bolt", "recycle", "bus", "truck-medical", "square-parking", "leaf"];
        const grid = document.getElementById('card-grid');

        Object.keys(caseData).forEach((id, i) => {
            grid.innerHTML += `
                <div onclick="openModal(${id})" class="initiative-card bg-white dark:bg-gray-800 p-6 rounded-xl border border-gray-200 dark:border-gray-700 shadow-md">
                    <i class="fa-solid fa-${icons[i]} text-cyan-450 text-3xl mb-4"></i>
                    <h3 class="font-bold text-lg mb-2">${id}. ${caseData[id].title}</h3>
                    <p class="text-xs text-gray-500">Click to view efficiency analysis and C++ implementation.</p>
                </div>
            `;
        });

        function openModal(id) {
            const data = caseData[id];
            document.getElementById('modalTitle').innerText = data.title;
            document.getElementById('modalProblem').innerText = data.problem;
            
            document.getElementById('modalDetails').innerHTML = `
                <span class="highlight-heading">Solution Approach</span>
                <p class="text-gray-700 dark:text-gray-300 mb-6">${data.approach}</p>
                <span class="highlight-heading">Documentation</span>
                <p class="text-gray-700 dark:text-gray-300 mb-6">${data.documentation}</p>
                <span class="highlight-heading">Efficiency Analysis</span>
                <p class="text-gray-700 dark:text-gray-300 mb-6">${data.efficiency}</p>
            `;

            const codeEl = document.getElementById('modalCode');
            codeEl.textContent = data.code;
            delete codeEl.dataset.highlighted;
            hljs.highlightElement(codeEl);
            document.getElementById('caseModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('caseModal').classList.remove('active');
        }
    </script>
</body>
</html>
