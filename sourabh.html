<!DOCTYPE html>
<html lang="en" class="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zabrosa City Portfolio</title>

<script src="https://cdn.tailwindcss.com"></script>
<script>
tailwind.config = {
  darkMode: 'class',
  theme: { extend: { colors: { cyan: { 450: '#00d4ff' } } } }
};
</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<style>
.modal { opacity:0; pointer-events:none; transition:0.3s }
.modal.active { opacity:1; pointer-events:auto }
pre { white-space: pre-wrap; word-wrap: break-word; }
</style>
</head>

<body class="bg-gray-900 text-gray-100">

<!-- BUSINESS CARDS EXIST ABOVE — UNCHANGED -->

<div id="caseModal" class="modal fixed inset-0 z-50 flex items-center justify-center p-4">
  <div class="absolute inset-0 bg-black/70" onclick="closeModal()"></div>
  <div class="bg-gray-800 rounded-xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-6">
    <h3 id="modalTitle" class="text-2xl font-bold mb-4"></h3>
    <p id="modalProblem" class="mb-4"></p>
    <p id="modalApproach" class="mb-4"></p>
    <pre><code id="modalCode" class="language-cpp"></code></pre>
    <pre><code id="modalDataPreview" class="language-csv"></code></pre>
  </div>
</div>

<script>
function openModal(id) {
  const c = caseData[id];
  if (!c) return;
  modalTitle.innerText = c.title;
  modalProblem.innerText = c.problem;
  modalApproach.innerHTML = c.approach.replace(/\n/g,"<br>");
  modalCode.textContent = c.code;
  modalDataPreview.textContent = c.dataset || "";
  caseModal.classList.add("active");
  hljs.highlightAll();
}
function closeModal() {
  caseModal.classList.remove("active");
}

/* ===================== CASE DATA (UNCHANGED CONTENT) ===================== */
const caseData = {
1:{
title:"Urban Road Maintenance and Asset Management",
problem:"Urban road networks are divided into multiple zones, each having varying levels of damage due to traffic load and environmental conditions. City authorities need to frequently update the damage values after inspections and efficiently calculate the total damage over a range of zones to prioritize maintenance work. A simple linear approach becomes inefficient as the number of zones increases.",
approach:"This problem is solved using a Segment Tree, which is a tree-based data structure designed for efficient range queries and updates. The segment tree stores cumulative damage values for ranges of road segments, allowing quick computation of total damage in any given interval.\n\n**Documentation:**In the system, each leaf node of the segment tree represents a single road segment, while internal nodes represent the sum of damage values of their child segments. When a road segment’s condition changes, only the relevant nodes in the tree are updated. Range queries traverse only the necessary branches, making the system suitable for real-time monitoring dashboards used by municipal authorities.\n**Efficiency Analysis:** The segment tree is built in O(n) time. Both update and query operations run in O(log n) time. The space complexity is O(n), making this approach scalable for large urban road networks.",
code:`#include <iostream>
using namespace std;
int seg[100];
void build(int arr[], int node, int start, int end) {
 if(start==end) seg[node]=arr[start];
 else{
  int mid=(start+end)/2;
  build(arr,2*node,start,mid);
  build(arr,2*node+1,mid+1,end);
  seg[node]=seg[2*node]+seg[2*node+1];
 }
}
int query(int node,int start,int end,int l,int r){
 if(r<start||l>end) return 0;
 if(l<=start&&end<=r) return seg[node];
 int mid=(start+end)/2;
 return query(2*node,start,mid,l,r)+query(2*node+1,mid+1,end,l,r);
}
int main(){
 int roadDamage[]={4,6,3,7,2};
 build(roadDamage,1,0,4);
 cout<<query(1,0,4,1,3);
}`
},

2:{
title:"Water Supply and Wastewater Management",
problem:"Water distribution systems consist of interconnected pipelines supplying water to different regions of a city. The key challenge is to verify whether water can reach all regions from the source and to identify disconnected or faulty pipeline segments that may disrupt supply.",
approach:"Breadth First Search (BFS) is used to traverse the pipeline network starting from the main water source. BFS explores all directly connected junctions before moving to the next level, effectively simulating water flow through the network.\n\n**Documentation:** In this system, pipeline junctions or tanks are represented as nodes and pipelines as edges in a graph. BFS uses a queue to visit nodes level by level and marks visited nodes. Any node that remains unvisited after traversal indicates a possible blockage or disconnection in the water supply network.\n**Efficiency Analysis:** The BFS algorithm runs in O(V + E) time, where V represents the number of junctions and E represents the number of pipelines. The space complexity is O(V) due to the queue and visited array.",
code:`#include <iostream>
using namespace std;
void bfs(int g[4][4]){
 int q[10],f=0,r=0,v[4]={0};
 q[r++]=0; v[0]=1;
 while(f<r){
  int u=q[f++];
  for(int i=0;i<4;i++)
   if(g[u][i]&&!v[i]){ v[i]=1; q[r++]=i; }
 }
}
int main(){
 int g[4][4]={{0,1,1,0},{1,0,0,1},{1,0,0,1},{0,1,1,0}};
 bfs(g);
}`
},

8:{
title:"Environmental Monitoring and Climate Resilience",
problem:"Environmental monitoring systems must track pollution levels across multiple locations where values are frequently updated. Authorities need fast computation of cumulative pollution levels for analysis and decision-making.",
approach:" A Fenwick Tree (Binary Indexed Tree) is used to efficiently support frequent updates and prefix sum queries on pollution data.\n\n**Documentation:** Each index of the Fenwick Tree represents a monitoring station. The tree stores partial sums, allowing pollution updates and cumulative queries to be processed efficiently, making it suitable for real-time monitoring dashboards.\n**Efficiency Analysis:** Both update and query operations run in O(log n) time, and the space complexity is O(n), making this approach scalable for large environmental datasets.",
code:`#include <iostream>
using namespace std;
int BIT[10],n=5;
void update(int i,int v){ while(i<=n){ BIT[i]+=v; i+=(i&-i);} }
int query(int i){ int s=0; while(i>0){ s+=BIT[i]; i-=(i&-i);} return s;}
int main(){
 update(1,40); update(2,30); update(3,20);
 cout<<query(3);
}`,
dataset:`SmartCode,Direction,SectorType,SectorNo,StreetNo,BuildingNo
NWSR-05-02-0145,NW,SR,5,2,145
SESC-12-07-0089,SE,SC,12,7,89
NESI-08-03-0234,NE,SI,8,3,234`
}
};
</script>

</body>
</html>

