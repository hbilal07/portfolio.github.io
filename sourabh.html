<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sourabh Kakarambi | Sustainable City Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { cyan: { 450: '#00d4ff' } } } }
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        h1, h2, h3, .brand-font { font-family: 'Space Grotesk', sans-serif; }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .initiative-card { transition: all 0.3s ease; cursor: pointer; }
        .initiative-card:hover { transform: translateY(-5px); border-color: #00d4ff; }
        .modal { transition: opacity 0.3s ease-in-out; opacity: 0; pointer-events: none; }
        .modal.active { opacity: 1; pointer-events: auto; }
        pre { white-space: pre; word-wrap: normal; overflow-x: auto; background: #282c34; padding: 1.5rem; border-radius: 0.5rem; }
        code { font-family: 'Consolas', 'Monaco', 'Courier New', monospace; line-height: 1.5; }
        .highlight-heading { color: #00d4ff; font-weight: 700; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.05em; margin-bottom: 0.5rem; display: block; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 flex flex-col min-h-screen">

    <nav class="bg-white/90 dark:bg-gray-900/95 backdrop-blur-md sticky top-0 z-40 border-b border-gray-200 dark:border-gray-700 shadow-sm transition-colors duration-300">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <i class="fa-solid fa-city text-cyan-450 text-2xl mr-2"></i>
                    <span class="brand-font text-xl font-bold text-gray-900 dark:text-white tracking-tight">Zabrosa City</span>
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <a href="index.html" class="text-gray-600 dark:text-gray-300 hover:text-cyan-450 transition">Home</a>
                    <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition">
                        <i id="theme-icon" class="fa-solid fa-sun text-yellow-500 text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow relative fade-in">
        <div class="max-w-7xl mx-auto px-4 py-16">
            <h1 class="text-4xl font-bold text-center mb-12">Sustainable City Initiatives</h1>
            <div id="card-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"></div>
        </div>
    </main>

    <div id="caseModal" class="modal fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm" onclick="closeModal()"></div>
        <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-2xl w-full max-w-6xl max-h-[90vh] overflow-hidden flex flex-col relative z-10">
            <div class="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 id="modalTitle" class="text-2xl font-bold text-cyan-450"></h3>
                <button onclick="closeModal()" class="text-gray-500 hover:text-white"><i class="fa-solid fa-xmark text-2xl"></i></button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <span class="highlight-heading">Problem Statement</span>
                        <p id="modalProblem" class="text-gray-700 dark:text-gray-300 mb-6"></p>
                        <div id="modalDetails"></div>
                    </div>
                    <div>
                        <span class="highlight-heading">C++ Implementation</span>
                        <div class="rounded-lg overflow-hidden border border-gray-700">
                            <pre><code id="modalCode" class="language-cpp"></code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleTheme() {
            const html = document.documentElement;
            html.classList.toggle('dark');
            const icon = document.getElementById('theme-icon');
            icon.classList.toggle('fa-sun');
            icon.classList.toggle('fa-moon');
        }

        const caseData = {
            1: {
                title: "Urban Road Maintenance and Asset Management",
                problem: "Urban road networks are divided into multiple zones, each having varying levels of damage due to traffic load and environmental conditions. City authorities need to frequently update the damage values after inspections and efficiently calculate the total damage over a range of zones to prioritize maintenance work.",
                approach: "This problem is solved using a Segment Tree, which is a tree-based data structure designed for efficient range queries and updates. The segment tree stores cumulative damage values for ranges of road segments.",
                documentation: "In the system, each leaf node of the segment tree represents a single road segment, while internal nodes represent the sum of damage values of their child segments.",
                efficiency: "The segment tree is built in O(n) time. Both update and query operations run in O(log n) time. The space complexity is O(n).",
                code: `#include <iostream>\nusing namespace std;\n\nint seg[4 * 100];\nint n;\n\n// Build Segment Tree\nvoid build(int arr[], int node, int start, int end) {\n    if (start == end) {\n        seg[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(arr, 2 * node, start, mid);\n        build(arr, 2 * node + 1, mid + 1, end);\n        seg[node] = seg[2 * node] + seg[2 * node + 1];\n    }\n}\n\n// Update damage after inspection\nvoid update(int node, int start, int end, int idx, int value) {\n    if (start == end) {\n        seg[node] = value;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid)\n            update(2 * node, start, mid, idx, value);\n        else\n            update(2 * node + 1, mid + 1, end, idx, value);\n        seg[node] = seg[2 * node] + seg[2 * node + 1];\n    }\n}\n\n// Query damage in a zone range\nint query(int node, int start, int end, int l, int r) {\n    if (r < start || l > end) return 0;\n    if (l <= start && end <= r) return seg[node];\n    int mid = (start + end) / 2;\n    return query(2 * node, start, mid, l, r) +\n           query(2 * node + 1, mid + 1, end, l, r);\n}\n\nint main() {\n    int roadDamage[] = {3, 5, 2, 6, 4};\n    n = 5;\n\n    build(roadDamage, 1, 0, n - 1);\n\n    cout << "Damage in Zone 1 to 3: " << query(1, 0, n - 1, 1, 3) << endl;\n\n    update(1, 0, n - 1, 2, 1);\n\n    cout << "Updated damage: " << query(1, 0, n - 1, 1, 3) << endl;\n\n    return 0;\n}`
            },
            2: {
                title: "Water Supply and Wastewater Management",
                problem: "Verifying whether water from a source can reach all regions from the source and identifying disconnected pipeline segments.",
                approach: "Breadth First Search (BFS) is used to traverse the pipeline network starting from the main water source.",
                documentation: "Junctions are represented as nodes and pipelines as edges. BFS uses a queue to visit nodes level by level.",
                efficiency: "The BFS algorithm runs in O(V + E) time, where V represents the junctions and E represents the pipelines.",
                code: `#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int zones = 5;\n    int pipes[5][5] = {\n        {0, 1, 1, 0, 0},\n        {1, 0, 0, 1, 0},\n        {1, 0, 0, 0, 1},\n        {0, 1, 0, 0, 0},\n        {0, 0, 1, 0, 0}\n    };\n\n    bool visited[5] = {false};\n    queue<int> q;\n\n    int source = 0; // water plant\n    visited[source] = true;\n    q.push(source);\n\n    cout << "Water reaches zones: ";\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cout << u << " ";\n\n        for (int v = 0; v < zones; v++) {\n            if (pipes[u][v] && !visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    return 0;\n}`
            },
            3: {
                title: "Smart Energy Grid Management",
                problem: "Connecting power substations with minimum cabling cost while ensuring the grid remains connected.",
                approach: "Prim’s Algorithm is used to generate a Minimum Spanning Tree (MST).",
                documentation: "Substations are vertices and costs are weighted edges. The algorithm selects the most economical connections.",
                efficiency: "The algorithm has a time complexity of O(V²) using an adjacency matrix.",
                code: `#include <iostream>\nusing namespace std;\n\n#define INF 999\n\nint main() {\n    int n = 4;\n    int cost[4][4] = {\n        {INF, 5, 8, INF},\n        {5, INF, 10, 15},\n        {8, 10, INF, 20},\n        {INF, 15, 20, INF}\n    };\n\n    bool visited[4] = {true, false, false, false};\n    int totalCost = 0;\n\n    for (int edges = 0; edges < n - 1; edges++) {\n        int min = INF, x = -1, y = -1;\n\n        for (int i = 0; i < n; i++)\n            if (visited[i])\n                for (int j = 0; j < n; j++)\n                    if (!visited[j] && cost[i][j] < min) {\n                        min = cost[i][j];\n                        x = i; y = j;\n                    }\n\n        visited[y] = true;\n        totalCost += min;\n        cout << "Power line: " << x << " -> " << y << endl;\n    }\n\n    cout << "Total Grid Cost: " << totalCost << endl;\n    return 0;\n}`
            },
            4: {
                title: "Solid Waste Collection and Recycling Optimization",
                problem: "Finding the shortest travel path for waste collection vehicles from a central depot to all zones.",
                approach: "Dijkstra’s Algorithm is used to determine the shortest paths from a central depot.",
                documentation: "Roads are weighted edges based on distance. The algorithm updates shortest known distances.",
                efficiency: "The time complexity is O(V²) and the space complexity is O(V).",
                code: `#include <iostream>\nusing namespace std;\n\n#define INF 999\n\nint main() {\n    int n = 5;\n    int graph[5][5] = {\n        {0, 4, INF, INF, 8},\n        {4, 0, 2, INF, 5},\n        {INF, 2, 0, 6, INF},\n        {INF, INF, 6, 0, 3},\n        {8, 5, INF, 3, 0}\n    };\n\n    int dist[5], visited[5] = {0};\n    for (int i = 0; i < n; i++) dist[i] = INF;\n    dist[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        int u = -1, min = INF;\n        for (int j = 0; j < n; j++)\n            if (!visited[j] && dist[j] < min) {\n                min = dist[j];\n                u = j;\n            }\n        \n        visited[u] = 1;\n        for (int v = 0; v < n; v++)\n            if (dist[u] + graph[u][v] < dist[v])\n                dist[v] = dist[u] + graph[u][v];\n    }\n\n    cout << "Minimum distance from depot:\\n";\n    for (int i = 0; i < n; i++)\n        cout << "Zone " << i << ": " << dist[i] << endl;\n\n    return 0;\n}`
            },
            5: {
                title: "Public Transport Scheduling and Optimization",
                problem: "Determining which transport service should depart next based on the earliest scheduled time.",
                approach: "A Min Heap is used to store departure times for O(1) retrieval of the next service.",
                documentation: "Each node represents a departure time. Root always provides the earliest dispatch.",
                efficiency: "Insertion takes O(log n) time. Retrieval takes O(1) time.",
                code: `#include <iostream>\nusing namespace std;\n\nint heap[50];\nint sz = 0;\n\nvoid insert(int time) {\n    heap[++sz] = time;\n    int i = sz;\n    while (i > 1 && heap[i] < heap[i / 2]) {\n        swap(heap[i], heap[i / 2]);\n        i /= 2;\n    }\n}\n\nint extractMin() {\n    int minVal = heap[1];\n    heap[1] = heap[sz--];\n\n    int i = 1;\n    while (2 * i <= sz) {\n        int child = 2 * i;\n        if (child + 1 <= sz && heap[child + 1] < heap[child])\n            child++;\n        if (heap[i] <= heap[child]) break;\n        swap(heap[i], heap[child]);\n        i = child;\n    }\n    return minVal;\n}\n\nint main() {\n    insert(15);\n    insert(5);\n    insert(20);\n\n    cout << "Next bus departure: " << extractMin() << " mins" << endl;\n\n    return 0;\n}`
            },
            6: {
                title: "Emergency Response Management",
                problem: "Mapping the propagation of a disaster (like a gas leak) through city zones quickly.",
                approach: "Depth First Search (DFS) is used to explore connectivity and mark all affected zones.",
                documentation: "Starts from source and recursively checks all interconnected paths.",
                efficiency: "The algorithm runs in O(V + E) time, making it highly responsive.",
                code: `#include <iostream>\nusing namespace std;\n\nint city[6][6] = {\n    {0, 1, 0, 0, 1, 0},\n    {1, 0, 1, 0, 0, 0},\n    {0, 1, 0, 1, 0, 0},\n    {0, 0, 1, 0, 1, 0},\n    {1, 0, 0, 1, 0, 1},\n    {0, 0, 0, 0, 1, 0}\n};\n\nbool visited[6];\n\nvoid dfs(int zone) {\n    visited[zone] = true;\n    cout << zone << " ";\n    for (int i = 0; i < 6; i++)\n        if (city[zone][i] && !visited[i])\n            dfs(i);\n}\n\nint main() {\n    cout << "Affected zones: ";\n    dfs(0); // disaster source\n    return 0;\n}`
            },
            7: {
                title: "Smart Parking – Slot Allocation System",
                problem: "Allocating slots fairly so vehicles are served in the order in which they arrive.",
                approach: "A Queue data structure is used to implement first-come-first-served allocation.",
                documentation: "Arriving vehicles enter the rear, and front vehicles receive available slots.",
                efficiency: "Operations take O(1) time and space complexity is O(n).",
                code: `#include <iostream>\nusing namespace std;\n\nint main() {\n    int parkingSlots[10];\n    int front = 0, rear = 0;\n\n    // Available slots added to queue\n    parkingSlots[rear++] = 101;\n    parkingSlots[rear++] = 102;\n    parkingSlots[rear++] = 103;\n\n    cout << "Car allocated slot: " << parkingSlots[front++] << endl;\n    cout << "Next available slot: " << parkingSlots[front] << endl;\n\n    return 0;\n}`
            },
            8: {
                title: "Environmental Monitoring and Climate Resilience",
                problem: "Tracking pollution levels that are frequently updated, requiring fast cumulative calculations.",
                approach: "A Fenwick Tree (Binary Indexed Tree) supports frequent updates and prefix sum queries.",
                documentation: "Each index is a station. BIT stores partial sums for efficient real-time analysis.",
                efficiency: "Update and query operations run in O(log n) time.",
                code: `#include <iostream>\nusing namespace std;\n\nint BIT[20];\nint n = 6;\n\nvoid update(int idx, int val) {\n    while (idx <= n) {\n        BIT[idx] += val;\n        idx += idx & -idx;\n    }\n}\n\nint query(int idx) {\n    int sum = 0;\n    while (idx > 0) {\n        sum += BIT[idx];\n        idx -= idx & -idx;\n    }\n    return sum;\n}\n\nint main() {\n    update(1, 35);\n    update(2, 40);\n    update(3, 30);\n    update(4, 25);\n\n    cout << "Total pollution till zone 4: " << query(4) << endl;\n\n    return 0;\n}`
            }
        };

        const icons = ["road", "water", "bolt", "recycle", "bus", "truck-medical", "square-parking", "leaf"];
        const grid = document.getElementById('card-grid');

        Object.keys(caseData).forEach((id, i) => {
            grid.innerHTML += `
                <div onclick="openModal(${id})" class="initiative-card bg-white dark:bg-gray-800 p-6 rounded-xl border border-gray-200 dark:border-gray-700 shadow-md">
                    <i class="fa-solid fa-${icons[i]} text-cyan-450 text-3xl mb-4"></i>
                    <h3 class="font-bold text-lg mb-2">${id}. ${caseData[id].title}</h3>
                    <p class="text-xs text-gray-500">Click to view efficiency analysis and C++ implementation.</p>
                </div>
            `;
        });

        function openModal(id) {
            const data = caseData[id];
            document.getElementById('modalTitle').innerText = data.title;
            document.getElementById('modalProblem').innerText = data.problem;
            
            document.getElementById('modalDetails').innerHTML = `
                <span class="highlight-heading">Solution Approach</span>
                <p class="text-gray-700 dark:text-gray-300 mb-6">${data.approach}</p>
                <span class="highlight-heading">Documentation</span>
                <p class="text-gray-700 dark:text-gray-300 mb-6">${data.documentation}</p>
                <span class="highlight-heading">Efficiency Analysis</span>
                <p class="text-gray-700 dark:text-gray-300 mb-6">${data.efficiency}</p>
            `;

            const codeEl = document.getElementById('modalCode');
            codeEl.textContent = data.code;
            delete codeEl.dataset.highlighted;
            hljs.highlightElement(codeEl);
            document.getElementById('caseModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('caseModal').classList.remove('active');
        }
    </script>
</body>
</html>
