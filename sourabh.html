<!DOCTYPE html>
<html lang="en" class="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sourabh Kakarambi | Sustainable City Portfolio</title>

<script src="https://cdn.tailwindcss.com"></script>
<script>
tailwind.config = {
darkMode: 'class',
theme: { extend: { colors: { cyan: { 450: '#00d4ff' } } } }
}
</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<style>
body { font-family:'Inter',sans-serif; }
h1,h2,h3,.brand-font { font-family:'Space Grotesk',sans-serif; }
.initiative-card { cursor:pointer; transition:.3s; }
.initiative-card:hover { transform:translateY(-5px); }
.modal { opacity:0; pointer-events:none; transition:.3s; }
.modal.active { opacity:1; pointer-events:auto; }
pre { white-space:pre-wrap; word-wrap:break-word; }
</style>
</head>

<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-100">

<!-- ================= MODAL ================= -->
<div id="caseModal" class="modal fixed inset-0 z-50 flex items-center justify-center p-4">
<div class="absolute inset-0 bg-black/70" onclick="closeModal()"></div>

<div class="bg-white dark:bg-gray-800 rounded-xl w-full max-w-6xl max-h-[90vh] overflow-y-auto relative z-10">

<div class="flex justify-between items-center p-6 border-b">
<h3 id="modalTitle" class="text-2xl font-bold"></h3>
<button onclick="closeModal()"><i class="fa-solid fa-xmark text-xl"></i></button>
</div>

<div class="p-6 grid grid-cols-1 lg:grid-cols-2 gap-6">

<div>
<h4 class="text-cyan-450 font-bold text-xs mb-1 uppercase">Problem Statement</h4>
<p id="modalProblem" class="mb-4"></p>

<h4 class="text-cyan-450 font-bold text-xs mb-1 uppercase">Solution Approach / Documentation</h4>
<p id="modalApproach"></p>
</div>

<div>
<h4 class="text-cyan-450 font-bold text-xs mb-1 uppercase">Implementation Code (C++)</h4>
<pre><code id="modalCode" class="language-cpp"></code></pre>
</div>

</div>
</div>
</div>

<script>
function openModal(id){
const c = caseData[id];
if(!c) return;

document.getElementById("modalTitle").textContent = c.title;
document.getElementById("modalProblem").textContent = c.problem;

document.getElementById("modalApproach").innerHTML =
c.approach
.replace(/\n/g,"<br>")
.replace(/\*\*(.*?)\*\*/g,'<span class="text-cyan-450 font-bold">$1</span>')
.replace(/O\((.*?)\)/g,'<span class="text-cyan-450 font-bold">O($1)</span>');

document.getElementById("modalCode").textContent = c.code;
hljs.highlightAll();
document.getElementById("caseModal").classList.add("active");
}

function closeModal(){
document.getElementById("caseModal").classList.remove("active");
}
</script>

<script>
/* ================= YOUR ORIGINAL BUSINESS CASE DATA (UNCHANGED CONTENT) ================= */

const caseData = {

1:{
title:"Urban Road Maintenance and Asset Management",
problem:"Urban road networks are divided into multiple zones, each having varying levels of damage due to traffic load and environmental conditions. City authorities need to frequently update the damage values after inspections and efficiently calculate the total damage over a range of zones to prioritize maintenance work. A simple linear approach becomes inefficient as the number of zones increases.",
approach:`This problem is solved using a Segment Tree, which is a tree-based data structure designed for efficient range queries and updates. The segment tree stores cumulative damage values for ranges of road segments, allowing quick computation of total damage in any given interval.

**Documentation:** In the system, each leaf node of the segment tree represents a single road segment, while internal nodes represent the sum of damage values of their child segments. When a road segment’s condition changes, only the relevant nodes in the tree are updated. Range queries traverse only the necessary branches, making the system suitable for real-time monitoring dashboards used by municipal authorities.

**Efficiency Analysis:** The segment tree is built in O(n) time. Both update and query operations run in O(log n) time. The space complexity is O(n), making this approach scalable for large urban road networks.`,
code:`#include <iostream>
using namespace std;

/*
 Segment Tree for Road Damage Monitoring
 Each index represents a road segment.
 Values represent damage severity (0–10 scale).
*/

int seg[4 * 100];
int n;

void build(int arr[], int node, int start, int end) {
    if (start == end) {
        seg[node] = arr[start];
    } else {
        int mid = (start + end) / 2;
        build(arr, 2*node, start, mid);
        build(arr, 2*node+1, mid+1, end);
        seg[node] = seg[2*node] + seg[2*node+1];
    }
}

void update(int node, int start, int end, int idx, int value) {
    if (start == end) {
        seg[node] = value;
    } else {
        int mid = (start + end) / 2;
        if (idx <= mid)
            update(2*node, start, mid, idx, value);
        else
            update(2*node+1, mid+1, end, idx, value);
        seg[node] = seg[2*node] + seg[2*node+1];
    }
}

int query(int node, int start, int end, int l, int r) {
    if (r < start || l > end) return 0;
    if (l <= start && end <= r) return seg[node];
    int mid = (start + end) / 2;
    return query(2*node, start, mid, l, r) +
           query(2*node+1, mid+1, end, l, r);
}

int main() {
    int roadDamage[] = {3, 5, 2, 6, 4};
    n = 5;

    build(roadDamage, 1, 0, n-1);

    cout << "Damage in Zone 1 to 3: "
         << query(1, 0, n-1, 1, 3) << endl;

    update(1, 0, n-1, 2, 1);

    cout << "Updated damage in Zone 1 to 3: "
         << query(1, 0, n-1, 1, 3) << endl;

    return 0;
}`
},

2:{
title:"Water Supply and Wastewater Management",
problem:"Water distribution systems consist of interconnected pipelines supplying water to different regions of a city. The key challenge is to verify whether water can reach all regions from the source and to identify disconnected or faulty pipeline segments that may disrupt supply.",
approach:`Breadth First Search (BFS) is used to traverse the pipeline network starting from the main water source. BFS explores all directly connected junctions before moving to the next level, effectively simulating water flow through the network.

**Documentation:** In this system, pipeline junctions or tanks are represented as nodes and pipelines as edges in a graph. BFS uses a queue to visit nodes level by level and marks visited nodes. Any node that remains unvisited after traversal indicates a possible blockage or disconnection in the water supply network.

**Efficiency Analysis:** The BFS algorithm runs in O(V + E) time, where V represents the number of junctions and E represents the number of pipelines. The space complexity is O(V) due to the queue and visited array.`,
code:`#include <iostream>
#include <queue>
using namespace std;

int main() {
    int zones = 5;
    int pipes[5][5] = {
        {0,1,1,0,0},
        {1,0,0,1,0},
        {1,0,0,0,1},
        {0,1,0,0,0},
        {0,0,1,0,0}
    };

    bool visited[5] = {false};
    queue<int> q;

    int source = 0;
    visited[source] = true;
    q.push(source);

    cout << "Water reaches zones: ";

    while (!q.empty()) {
        int u = q.front(); q.pop();
        cout << u << " ";
        for (int v = 0; v < zones; v++) {
            if (pipes[u][v] && !visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
    return 0;
}`
},

3:{
title:"Smart Energy Grid Management",
problem:"Energy providers must connect multiple power substations using electrical cables such that the entire grid remains connected with the minimum possible installation cost. Poor planning can result in unnecessary expenditure.",
approach:`Prim’s Algorithm is used to generate a Minimum Spanning Tree (MST). The algorithm starts from a selected substation and repeatedly adds the lowest-cost edge that connects a visited node to an unvisited one, ensuring minimum total cost without cycles.

**Documentation:** In the system model, substations are treated as graph vertices and cable installation costs as weighted edges. Prim’s Algorithm incrementally builds the power grid by selecting the most economical connections, resulting in a fully connected and cost-optimized energy network.

**Efficiency Analysis:** Using an adjacency matrix, Prim’s Algorithm has a time complexity of O(V²) and a space complexity of O(V). This is suitable for moderate-sized power grids.`,
code:`#include <iostream>
using namespace std;

#define INF 999

int main() {
    int n = 4;
    int cost[4][4] = {
        {INF,5,8,INF},
        {5,INF,10,15},
        {8,10,INF,20},
        {INF,15,20,INF}
    };

    bool visited[4] = {true,false,false,false};
    int totalCost = 0;

    for (int edges = 0; edges < n-1; edges++) {
        int min = INF, x = -1, y = -1;

        for (int i = 0; i < n; i++)
            if (visited[i])
                for (int j = 0; j < n; j++)
                    if (!visited[j] && cost[i][j] < min) {
                        min = cost[i][j];
                        x = i; y = j;
                    }

        visited[y] = true;
        totalCost += min;
        cout << "Power line: " << x << " -> " << y << endl;
    }

    cout << "Total Grid Cost: " << totalCost << endl;
    return 0;
}`
}

};

</script>

</body>
</html>



