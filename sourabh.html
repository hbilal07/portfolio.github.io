<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sourabh Kakarambi | Sustainable City Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { cyan: { 450: '#00d4ff' } } } }
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        h1, h2, h3, .brand-font { font-family: 'Space Grotesk', sans-serif; }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .initiative-card { transition: all 0.3s ease; cursor: pointer; }
        .initiative-card:hover { transform: translateY(-5px); border-color: #00d4ff; }
        .modal { transition: opacity 0.3s ease-in-out; opacity: 0; pointer-events: none; }
        .modal.active { opacity: 1; pointer-events: auto; }
        pre { white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; font-size: 0.85rem; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100 flex flex-col min-h-screen">

    <nav class="bg-white/90 dark:bg-gray-900/95 backdrop-blur-md sticky top-0 z-40 border-b border-gray-200 dark:border-gray-700 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <i class="fa-solid fa-city text-cyan-450 text-2xl mr-2"></i>
                    <span class="brand-font text-xl font-bold text-gray-900 dark:text-white tracking-tight">Zabrosa City</span>
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <a href="index.html" class="text-gray-600 dark:text-gray-300 hover:text-cyan-450 transition">Home</a>
                    <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition">
                        <i id="theme-icon" class="fa-solid fa-sun text-yellow-500 text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow relative fade-in">
        <div class="max-w-7xl mx-auto px-4 py-16">
            <h1 class="text-4xl font-bold text-center mb-12">Sustainable City Initiatives</h1>
            <div id="grid-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"></div>
        </div>
    </main>

    <div id="caseModal" class="modal fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm" onclick="closeModal()"></div>
        <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-2xl w-full max-w-6xl max-h-[90vh] overflow-hidden flex flex-col relative z-10">
            <div class="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 id="modalTitle" class="text-2xl font-bold text-cyan-450"></h3>
                <button onclick="closeModal()" class="text-gray-500 hover:text-white"><i class="fa-solid fa-xmark text-2xl"></i></button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <h4 class="text-cyan-450 font-bold uppercase text-xs mb-2">Problem Statement</h4>
                        <p id="modalProblem" class="text-gray-700 dark:text-gray-300 mb-6"></p>
                        <h4 class="text-cyan-450 font-bold uppercase text-xs mb-2">Technical Analysis</h4>
                        <p id="modalApproach" class="text-gray-700 dark:text-gray-300 mb-6"></p>
                    </div>
                    <div>
                        <h4 class="text-cyan-450 font-bold uppercase text-xs mb-2">Accurate C++ Implementation</h4>
                        <div class="rounded-lg overflow-hidden border border-gray-700">
                            <pre><code id="modalCode" class="language-cpp"></code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleTheme() {
            const html = document.documentElement;
            html.classList.toggle('dark');
            const icon = document.getElementById('theme-icon');
            icon.classList.toggle('fa-sun');
            icon.classList.toggle('fa-moon');
        }

        const caseData = {
            1: {
                title: "Urban Road Maintenance and Asset Management",
                problem: "Urban road networks have varying damage levels. Authorities need to update damage values and calculate total damage over specific zone ranges efficiently.",
                approach: "**Algorithm:** Segment Tree\n**Efficiency:** O(log n) for both Update and Query.\n**Documentation:** Stores cumulative damage in a tree structure. Leaf nodes represent single segments; internal nodes represent range sums.",
                code: `#include <iostream>\nusing namespace std;\n\nint seg[4 * 100], n;\n\nvoid build(int arr[], int node, int start, int end) {\n    if (start == end) { seg[node] = arr[start]; }\n    else {\n        int mid = (start + end) / 2;\n        build(arr, 2*node, start, mid);\n        build(arr, 2*node+1, mid+1, end);\n        seg[node] = seg[2*node] + seg[2*node+1];\n    }\n}\n\nvoid update(int node, int start, int end, int idx, int value) {\n    if (start == end) { seg[node] = value; }\n    else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) update(2*node, start, mid, idx, value);\n        else update(2*node+1, mid+1, end, idx, value);\n        seg[node] = seg[2*node] + seg[2*node+1];\n    }\n}\n\nint query(int node, int start, int end, int l, int r) {\n    if (r < start || l > end) return 0;\n    if (l <= start && end <= r) return seg[node];\n    int mid = (start + end) / 2;\n    return query(2*node, start, mid, l, r) + query(2*node+1, mid+1, end, l, r);\n}\n\nint main() {\n    int roadDamage[] = {3, 5, 2, 6, 4}; n = 5;\n    build(roadDamage, 1, 0, n-1);\n    cout << "Damage in Zone 1 to 3: " << query(1, 0, n-1, 1, 3) << endl;\n    update(1, 0, n-1, 2, 1);\n    cout << "Updated damage in Zone 1 to 3: " << query(1, 0, n-1, 1, 3) << endl;\n    return 0;\n}`
            },
            2: {
                title: "Water Supply and Wastewater Management",
                problem: "Verifying if water from a source can reach all districts and identifying disconnected pipeline segments.",
                approach: "**Algorithm:** Breadth-First Search (BFS)\n**Efficiency:** O(V + E)\n**Documentation:** Traverses the pipeline graph level-by-level using a queue to ensure all reachable junctions are marked.",
                code: `#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int zones = 5;\n    int pipes[5][5] = {{0,1,1,0,0},{1,0,0,1,0},{1,0,0,0,1},{0,1,0,0,0},{0,0,1,0,0}};\n    bool visited[5] = {false};\n    queue<int> q;\n    int source = 0; visited[source] = true; q.push(source);\n    cout << "Water reaches zones: ";\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        cout << u << " ";\n        for (int v = 0; v < zones; v++) {\n            if (pipes[u][v] && !visited[v]) {\n                visited[v] = true; q.push(v);\n            }\n        }\n    }\n    return 0;\n}`
            },
            3: {
                title: "Smart Energy Grid Management",
                problem: "Connecting power substations with minimum cabling cost while ensuring the entire grid is connected.",
                approach: "**Algorithm:** Prim's Algorithm (MST)\n**Efficiency:** O(V^2) with adjacency matrix.\n**Documentation:** Greedily adds the cheapest connection from a visited node to an unvisited node.",
                code: `#include <iostream>\nusing namespace std;\n#define INF 999\n\nint main() {\n    int n = 4;\n    int cost[4][4] = {{INF,5,8,INF},{5,INF,10,15},{8,10,INF,20},{INF,15,20,INF}};\n    bool visited[4] = {true,false,false,false};\n    int totalCost = 0;\n    for (int edges = 0; edges < n-1; edges++) {\n        int min = INF, x = -1, y = -1;\n        for (int i = 0; i < n; i++)\n            if (visited[i])\n                for (int j = 0; j < n; j++)\n                    if (!visited[j] && cost[i][j] < min) { min = cost[i][j]; x = i; y = j; }\n        visited[y] = true; totalCost += min;\n        cout << "Power line: " << x << " -> " << y << endl;\n    }\n    cout << "Total Grid Cost: " << totalCost << endl;\n    return 0;\n}`
            },
            4: {
                title: "Solid Waste Collection Optimization",
                problem: "Finding the shortest travel path for waste collection vehicles from the central depot to all collection zones.",
                approach: "**Algorithm:** Dijkstra's Algorithm\n**Efficiency:** O(V^2)\n**Documentation:** Calculates the single-source shortest path by maintaining a set of minimum distances to each node.",
                code: `#include <iostream>\nusing namespace std;\n#define INF 999\n\nint main() {\n    int n = 5;\n    int graph[5][5] = {{0,4,INF,INF,8},{4,0,2,INF,5},{INF,2,0,6,INF},{INF,INF,6,0,3},{8,5,INF,3,0}};\n    int dist[5], visited[5] = {0};\n    for(int i=0;i<n;i++) dist[i]=INF; dist[0]=0;\n    for(int i=0;i<n;i++){\n        int u=-1,min=INF;\n        for(int j=0;j<n;j++) if(!visited[j] && dist[j]<min){ min=dist[j]; u=j; }\n        visited[u]=1;\n        for(int v=0;v<n;v++) if(dist[u]+graph[u][v]<dist[v]) dist[v]=dist[u]+graph[u][v];\n    }\n    cout<<"Minimum distance from depot:\\n";\n    for(int i=0;i<n;i++) cout<<"Zone "<<i<<": "<<dist[i]<<endl;\n    return 0;\n}`
            },
            5: {
                title: "Public Transport Scheduling",
                problem: "Dynamically determining which bus should depart next based on the earliest scheduled time.",
                approach: "**Algorithm:** Min-Heap\n**Efficiency:** O(log n) for Insertion, O(1) for Retrieval.\n**Documentation:** Ensures the smallest timestamp is always at the root of the heap.",
                code: `#include <iostream>\nusing namespace std;\nint heap[50], sz = 0;\nvoid insert(int time) {\n    heap[++sz] = time; int i = sz;\n    while (i > 1 && heap[i] < heap[i/2]) { swap(heap[i], heap[i/2]); i /= 2; }\n}\nint extractMin() {\n    int min = heap[1]; heap[1] = heap[sz--]; int i = 1;\n    while (2*i <= sz) {\n        int child = 2*i;\n        if (child+1 <= sz && heap[child+1] < heap[child]) child++;\n        if (heap[i] <= heap[child]) break;\n        swap(heap[i], heap[child]); i = child;\n    }\n    return min;\n}\nint main() {\n    insert(15); insert(5); insert(20);\n    cout << "Next bus departure in minutes: " << extractMin() << endl;\n    return 0;\n}`
            },
            6: {
                title: "Emergency Response & Disaster Mapping",
                problem: "Identifying all city zones that could be affected by a spreading disaster (like a gas leak) from a single source.",
                approach: "**Algorithm:** Depth-First Search (DFS)\n**Efficiency:** O(V + E)\n**Documentation:** Recursively explores all paths from the disaster source to identify connected/impacted zones.",
                code: `#include <iostream>\nusing namespace std;\nint city[6][6] = {{0,1,0,0,1,0},{1,0,1,0,0,0},{0,1,0,1,0,0},{0,0,1,0,1,0},{1,0,0,1,0,1},{0,0,0,0,1,0}};\nbool visited[6];\nvoid dfs(int zone) {\n    visited[zone] = true; cout << zone << " ";\n    for (int i = 0; i < 6; i++) if (city[zone][i] && !visited[i]) dfs(i);\n}\nint main() { cout << "Affected zones: "; dfs(0); return 0; }`
            },
            7: {
                title: "Smart Parking Allocation",
                problem: "Allocating parking slots in the order vehicles arrive (First-Come, First-Served).",
                approach: "**Algorithm:** Queue (Array Implementation)\n**Efficiency:** O(1)\n**Documentation:** Uses Front and Rear pointers to manage a stream of vehicles and slot IDs.",
                code: `#include <iostream>\nusing namespace std;\nint main() {\n    int parkingSlots[10]; int front = 0, rear = 0;\n    parkingSlots[rear++] = 101; parkingSlots[rear++] = 102; parkingSlots[rear++] = 103;\n    cout << "Car allocated slot: " << parkingSlots[front++] << endl;\n    cout << "Next available slot: " << parkingSlots[front] << endl;\n    return 0;\n}`
            },
            8: {
                title: "Environmental Monitoring",
                problem: "Tracking pollution levels where values are updated frequently, requiring fast prefix sum calculations.",
                approach: "**Algorithm:** Fenwick Tree (Binary Indexed Tree)\n**Efficiency:** O(log n) Update/Query\n**Documentation:** Efficiently maintains prefix sums for pollution data using bitwise index manipulation.",
                code: `#include <iostream>\nusing namespace std;\nint BIT[20], n = 6;\nvoid update(int idx, int val) { while (idx <= n) { BIT[idx] += val; idx += idx & -idx; } }\nint query(int idx) { int sum = 0; while (idx > 0) { sum += BIT[idx]; idx -= idx & -idx; } return sum; }\nint main() { update(1, 35); update(2, 40); update(3, 30); update(4, 25);\n    cout << "Total pollution till zone 4: " << query(4) << endl; return 0; }`
            }
        };

        const icons = ["road", "water", "bolt", "recycle", "bus", "truck-medical", "square-p", "leaf"];
        const grid = document.getElementById('grid-container');
        
        Object.keys(caseData).forEach((id, i) => {
            grid.innerHTML += `
                <div onclick="openModal(${id})" class="initiative-card bg-white dark:bg-gray-800 p-6 rounded-xl border border-gray-200 dark:border-gray-700 shadow-md">
                    <i class="fa-solid fa-${icons[i]} text-cyan-450 text-3xl mb-4"></i>
                    <h3 class="font-bold text-lg mb-2">${id}. ${caseData[id].title}</h3>
                    <p class="text-xs text-gray-500">Optimized with DSA for Zabrosa City.</p>
                </div>
            `;
        });

        function openModal(id) {
            const data = caseData[id];
            document.getElementById('modalTitle').innerText = data.title;
            document.getElementById('modalProblem').innerText = data.problem;
            document.getElementById('modalApproach').innerText = data.approach;
            const codeEl = document.getElementById('modalCode');
            codeEl.textContent = data.code;
            delete codeEl.dataset.highlighted;
            hljs.highlightElement(codeEl);
            document.getElementById('caseModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('caseModal').classList.remove('active');
        }
    </script>
</body>
</html>
